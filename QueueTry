#ifndef _QUEUE_H
#define _QUEUE_H
#include "ex6.h"

// A linked list (LL) node to store a queue entry
typedef struct QNode {
	TrinAri * person;
	struct QNode* nextPerson;
}QNode;

// The queue, front stores the front node of LL and rear stores the
// last node of LL
typedef struct Queue {
	struct QNode *first;
}Queue;


Queue* createQueue();
//q - the queue, k- the key (element)
int enQueue(Queue* q, void* k);
void deQueue(Queue* q);
// retutn 1 if empty and zero if not empty
int isEmpty(Queue* q);
void destroyQueue(Queue* q);

void appendToQueue(Queue* q, TrinAri* toAdd);
void printQueue(Queue* q);

#endif








//
// Created by MrMsaar on 31/12/2020.
//

#include "queue.h"
#include "stdio.h"
#include "stdlib.h"

void appendToQueue(Queue* q, TrinAri* toAdd){
    QNode* newNode = malloc(sizeof(QNode));//???free???
    if (toAdd == NULL){
        newNode->person =NULL;
        return;
    }
    QNode* current = q->first;
    QNode* previous = q->first;
    while (current != NULL){
        previous = current;
        current = current->nextPerson;
    }
    newNode->person = toAdd;
    newNode->nextPerson = NULL;
    if (previous == NULL){
        q->first = newNode;
        return;
    }
    previous->nextPerson = newNode;
}

int isEmpty(Queue* q){
    if (q->first == NULL){
        return 1;
    }
    return 0;
}

//frees al nodes
void destroyQNodes(QNode* node){
    if (node == NULL){
        return;
    }
    destroyQNodes(node->nextPerson);
    free(node);
}

//destroy all nodes
void destroyQueue(Queue* q){
    destroyQNodes(q->first);
}

void printQueue(Queue* q){
    QNode* current = q->first;
    while (current != NULL){
        printf("%d %s\n", current->person->id, current->person->name);
        current = current->nextPerson;
    }
}







//
// implied in ex6.c
//

void runBFS(TrinAri* root, Queue* visited, Queue* notVisited){
    if (root == NULL){
        return;
    }
    appendToQueue(notVisited, root->left);
    appendToQueue(notVisited, root->middle);
    appendToQueue(notVisited, root->right);
    appendToQueue(visited, root);
    notVisited->first = notVisited->first->nextPerson;
    //need to find a way to remove from top of list
    if (notVisited->first == NULL){
        runBFS(NULL, visited, notVisited);
    }
    else{
        runBFS(notVisited->first->person, visited, notVisited);
    }
}

void printBFS(TrinAri* root){
    Queue visited;
    Queue notVisited;
    visited.first = NULL;
    notVisited.first = NULL;
    appendToQueue(&notVisited, root);
    runBFS(root, &visited, &notVisited);
    printQueue(&visited);
    destroyQueue(&visited);
    destroyQueue(&notVisited);
}
